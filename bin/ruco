#!/usr/bin/env ruby
# encoding: UTF-8
require 'curses'
require 'optparse'
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

def parse_options
  options = {}
  parser = OptionParser.new do |opts|
    opts.banner = <<BANNER
[Ru]by [Co]mmandline editor

Shortcuts:
 Ctrl+w/q   Exit
 Ctrl+s     Save

Usage:
    ruco FILE

Options:
BANNER
    opts.on("-c", "--convert-tabs","Convert tabs to spaces") { options[:convert_tabs] = true }
    opts.on("--convert-return","Convert \\r characters to \\n") { options[:convert_return] = true }
    opts.on("--debug-cache","Show caching in action") { options[:debug_cache] = true }
    opts.on("--debug-keys", "Show pressed keys") { options[:debug_keys] = true }
    opts.on("-v", "--version","Show Version"){
      require 'ruco/version'
      puts Ruco::VERSION
      exit
    }
    opts.on("-h", "--help","Show this.") { puts opts; exit }
  end
  parser.parse!

  if ARGV.empty?
    puts parser
    exit
  end

  options
end

def write(line,row,text)
  Curses.setpos(line,row)
  Curses.addstr(text);
end

def init_screen
  Curses.noecho # do not show typed chars
  Curses.nonl # turn off newline translation
  Curses.stdscr.keypad(true) # enable arrow keys
  Curses.raw # give us all other keys
  Curses.stdscr.nodelay = 1 # do not block -> we can use timeouts
  Curses.init_screen

  begin
    yield
  ensure
    Curses.close_screen
  end
end

def display(lines, offset, color_mask)
  @screen ||= [] # current screen is used as cache
  color_mask = color_mask.flatten

  lines.each_with_index do |content, line|
    colors = color_mask[line]

    # expand line with whitespace
    line += offset
    clearer = Curses.stdscr.maxx - content.size
    clearer = " " * clearer
    content += clearer
    content.gsub!("\t",' ') # display tabs as single-space -> nothing breaks

    # cache !?
    next if @screen[line] == [content, colors]
    @screen[line] = [content, colors]

    # position at start of line
    Curses.setpos(line,0)
    Curses.attrset(Curses::A_NORMAL)

    if colors
      buffered = ''
      colors.each_with_index do |color,i|
        if color
          # write buffer
          Curses.addstr(buffered)
          buffered = ''

          # set new color
          color = (color.empty? ? Curses::A_NORMAL : Curses::A_REVERSE)
          Curses.attrset color
        end
        buffered << (content[i..i]||'')
      end
      Curses.addstr(buffered)
    else
      Curses.addstr(content)
    end

    write(line, 0, (rand(899)+100).to_s) if @options[:debug_cache]
  end
end

def show_app(app)
  lines = app.view.naive_split("\n")
  color_mask = app.color_mask

  # TODO move this logic into application
  first = color_mask.shift
  last = color_mask.pop
  display([lines.first], 0, first)
  display(lines[1..-2], 1, color_mask)
  display([lines.last], Curses.stdscr.maxy - 1, last)

  Curses.setpos(app.cursor.line, app.cursor.column)
end

def debug_key(key)
  @key_line ||= -1
  @key_line = (@key_line + 1) % Curses.stdscr.maxy
  write(@key_line, 0, "#{key.inspect}---")
end

def log(stuff)
  File.open('ruco.log','a'){|f| f.puts stuff }
end

@options = parse_options

require 'ruco'

app = Ruco::Application.new(ARGV[0],
  :convert_tabs => @options[:convert_tabs],
  :convert_return => @options[:convert_return],
  :lines => Curses.stdscr.maxy, :columns => Curses.stdscr.maxx
)

init_screen do
  show_app app

  Keyboard.input do
    Curses.getch
  end

  Keyboard.output do |key|
    debug_key(key) if @options[:debug_keys]
    if key == :resize
      app.resize(Curses.stdscr.maxy, Curses.stdscr.maxx)
      @screen.clear # clear cache
    else
      result = app.key key
    end
    break if result == :quit
    show_app app
  end
end