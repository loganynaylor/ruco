#!/usr/bin/env ruby
# encoding: UTF-8
require 'curses'
require 'optparse'
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

def parse_options
  options = {}
  parser = OptionParser.new do |opts|
    opts.banner = <<BANNER
[Ru]by [Co]mmandline editor

Shortcuts:
 Ctrl+w/q   Exit
 Ctrl+s     Save

Usage:
    ruco FILE

Options:
BANNER
    opts.on("-c", "--convert-tabs","Convert tabs to spaces") { options[:convert_tabs] = true }
    opts.on("-u", "--undo-stack-size SIZE","Maximum size of the undo stack.  0 allows for a complete undo stack.") {|size| options[:undo_stack_size] = size.to_i }
    opts.on("--no-colors","No colors -- helps performance / broken terminals") { options[:no_colors] = true }
    opts.on("--debug-cache","Show caching in action") { options[:debug_cache] = true }
    opts.on("--debug-keys", "Show pressed keys") { options[:debug_keys] = true }
    opts.on("-v", "--version","Show Version"){
      require 'ruco/version'
      puts Ruco::VERSION
      exit
    }
    opts.on("-h", "--help","Show this.") { puts opts; exit }
  end
  parser.parse!

  if ARGV.empty?
    puts parser
    exit
  end

  options
end

def log(stuff)
  File.open('ruco.log','ab'){|f| f.puts stuff }
end

options = parse_options
$ruco_no_colors = options[:no_colors]

require 'ruco'

# draw app and redraw after each keystroke (or paste)
Ruco::Screen.open(options) do |screen|
  app = Ruco::Application.new(ARGV[0],
    :convert_tabs => options[:convert_tabs],
    :undo_stack_size => options[:undo_stack_size],
    :lines => screen.lines, :columns => screen.columns
  )

  screen.draw *app.display_info

  Keyboard.input do
    Curses.getch
  end

  Keyboard.output do |key|
    screen.debug_key(key) if options[:debug_keys]
    if key == :resize
      app.resize(lines, columns)
      screen.clear_cache
    else
      result = app.key key
      break if result == :quit
    end
    
    screen.draw *app.display_info
  end
end
