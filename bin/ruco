#!/usr/bin/env ruby
require 'curses'
require 'optparse'
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

def parse_options
  options = OptionParser.new do |opts|
    opts.banner = <<BANNER
[Ru]by [Co]mmandline editor

Shortcuts:
 Ctrl+w/q   Exit
 Ctrl+s     Save

Usage:
    ruco FILE

Options:
BANNER
    opts.on("-h", "--help","Show this.") { puts opts; exit }
  end
  options.parse!

  if ARGV.empty?
    puts options
    exit
  end
end

def write(line,row,text)
  Curses.setpos(line,row)
  Curses.addstr(text);
end

def init_screen
  Curses.noecho # do not show typed chars
  Curses.init_screen
  Curses.stdscr.keypad(true) # enable arrow keys
  Curses.raw # give us all other keys

  begin
    yield
  ensure
    Curses.close_screen
  end
end

def display(lines, offset, color)
  Curses.attrset color
  Curses.stdscr.maxy.times do |i|
    line = lines[i] || ''
    clearer = Curses.stdscr.maxx - line.size
    clearer = " " * clearer
    write(i + offset, 0, line + clearer)
  end
end

def show_app(app)
  lines = app.view.naive_split("\n")

  # TODO move this logic into application
  display([lines.first], 0, Curses::A_REVERSE)
  display(lines[1..-2], 1, Curses::A_NORMAL)
  display([lines.last], Curses.stdscr.maxy - 1, Curses::A_REVERSE)

  Curses.setpos(app.cursor.line, app.cursor.column)
end

parse_options

require 'ruco'
require 'ruco/keyboard' # needs curses <-> not loaded for specs

app = Ruco::Application.new(ARGV[0], :lines => Curses.stdscr.maxy, :columns => Curses.stdscr.maxx)

init_screen do
  show_app app

  Keyboard.listen do |key|
    result = app.key key
    break if result == :quit
    show_app app
  end
end